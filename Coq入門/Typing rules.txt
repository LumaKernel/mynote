ローカルコンテキスト：変数と呼ばれる，順序付けされた宣言(e.g. t:T や y := u : U など)の列
グローバル環境：仮定(assumption)や定義と呼ばれる，順序付けされた宣言(e.g. t:T や y := u : U など)の列


Inductive definition は仮定規則 (assumption rule) としてみなす (なにそれ)



E[Γ] |- t: T
グローバル環境E と ローカルコンテキストΓのもとで，tがTという型であるということ (well-typed)

WF(E)[Γ]
グローバル環境Eがwell-formedであり，ローカルコンテキストΓが，そのEのもとで妥当である，ということ


項tがwell-typedであるとは，グローバル環境Eに対して，あるΓがあって，E[Γ] ⊢ t : T が型付け規則において導かれることである (証明論ということだね)


W-Empty : 空のグローバル環境はwell-formedであり，空のローカルコンテキストは妥当である

W-Local-Assum :
  Tを型とする変数を追加する感じ． ( Variable x : T. )
  T は Sorts の型のうちのいずれかを，型としてもたないといけない．
  変数の二重定義を禁止している


W-Local-Def :
  別名をつけるってこと． ( Definition x : nat := 1 + 1. )

W-Global-Assum :
  なんのローカルコンテキストもなしに T : s を導いたなら，Tが型であることがわかったので，
  Tの型をもつ値を仮定にいれてもいい．
  (よくわからないが，Axiomの型が型であるとわかっていないとダメだよ，って話だと思う)


W-Global-Def :
  上記の定義版．


Ax-SProp :
  SProp は 言わずもがな，型だよ！という公理

Ax-Prop :
  同様．Propは型だよ！

Ax-Set :
  同様．

Ax-Type :
  型の型も型だよ！ただし階層構造になっているよ！
  循環するとまずいことがある．


Var :
  EにおいてΓが妥当であるなら，Γに含まれる項，つまり宣言はE[Γ]においてwell-typedであるよ，ということ
  つまり，証明論のような操作をするための，出発点にできるということだとおもう

Const : 
  Eに含まれるやつも，Varと同様だよ，ということ
  つまり，この体系は，暗に，グローバル内の宣言は定数で，ローカル内の宣言は変数だと言っているということか？

Prod-SPorp :
Prod-Porp :
  Uが命題なら(∀x:T,U)も命題だよ，という話
  ただし，x:T であるときにUが命題，ということだけわかればいい
  つまりつまり，x:TでないときにUが命題でないようなもんでも，まあいいってことか


Prod-Set :
  構造としては上記とにている．
  写像の集合などを定義する．例えば，(forall x:nat, nat) はこの規則で Set だといえるが，
  これは， nat -> nat ，つまり写像の集合 Map(N, N)を表している


Prod-Type :
  単に型であった場合，(∀x:T,U) も型．
  メタ的なものだと思う．Prop -> Prop という，命題を変換する写像の集まりは，Typeということであって，
  我々が議論する中で現れる集合，つまりSetとは区別するということだと思う．


上4つをまとめると，forall x:A, U の型はUで決定していいということだ．そこに，Aに対する制約の違いがあったりする．


Lam :
  λx:T. t の型が，x:Tのもとで t:U なら， forall x:T, U だよね，という話

App :
  関数適用の型を決めている


Let :
  let ... in の型























